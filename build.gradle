buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.guardsquare:proguard-gradle:7.1.0'
    }
}

allprojects {
    repositories {
        mavenCentral()
        google()
    }
}

apply plugin: 'java-library'

// Værdien kan være mellem 7 og 9. JDK 10+ fanges ikke af Android Studio
sourceCompatibility = "8"
compileJava.options.encoding = "UTF-8"
compileTestJava.options.encoding = "UTF-8"

compileJava {
    targetCompatibility = '1.8'
}
dependencies {
    // REST-server: Javalin
    compile 'io.javalin:javalin:3.7.0'
    implementation "org.slf4j:slf4j-simple:1.7.28" // Nødvendig til javalin
    // JSON-parser Jackson
    //implementation 'com.fasterxml.jackson.core:jackson-databind:2.10.1'
    // Men kan bedre lide gson, der fylder en del mindre:
    implementation 'com.google.code.gson:gson:2.8.6'

    // REST-klient: Unirest
    implementation 'com.konghq:unirest-java:3.4.03'
    //implementation 'com.mashape.unirest:unirest-java:1.4.9'

    // Parsning af kommandolinjeparametre - se https://picocli.info/
    implementation 'info.picocli:picocli:4.2.0'

    // For at Cloud Run kan gemme filer....
    implementation 'com.google.cloud:google-cloud-storage:1.104.0'

    // Afprøvning
    testCompile("org.junit.jupiter:junit-jupiter-api:5.6.0")
    testRuntime("org.junit.jupiter:junit-jupiter-engine:5.6.0")
    //testRuntime("org.junit.platform:junit-platform-runner:1.6.0")
}


test {
    useJUnitPlatform()
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
}


task ('proguard', type: proguard.gradle.ProGuardTask) {

    // You should probably import a more compact ProGuard-style configuration
    // file for all static settings, but we're specifying them all here, for
    // the sake of the example.
    //configuration 'configuration.pro'

    verbose

    // Specify the input jars, output jars, and library jars.
    // In this case, the input jar is the program library that we want to process.

    injars  rootProject.file(
            "build/libs/${project.name}.jar")
    outjars rootProject.file(
            "build/libs/${project.name}-shrinked.jar")


    // Automatically handle the Java version of this build.
    if (System.getProperty('java.version').startsWith('1.')) {
        // Before Java 9, the runtime classes were packaged in a single jar file.
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        // As of Java 9, the runtime classes are packaged in modular jmod files.
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        //libraryjars "${System.getProperty('java.home')}/jmods/....."
        println("xxxxx "+System.getProperty('java.version'))
        println("xxxxx "+System.getProperty('java.home'))
    }

    // Save the obfuscation mapping to a file, so we can de-obfuscate any stack
    // traces later on. Keep a fixed source file attribute and all line number
    // tables to get line numbers in the stack traces.
    // You can comment this out if you're not interested in stack traces.

    printmapping 'out.map'
    keepparameternames
    keepattributes 'Signature,Exceptions,InnerClasses,PermittedSubclasses,EnclosingMethod,Deprecated,SourceFile,LineNumberTable'

    // Preserve all annotations.
    keepattributes '*Annotation*'

    // Preserve all public classes, and their public and protected fields and
    // methods.
    keep 'public class * { \
        public protected *; \
    }'

    // Preserve all .class method names.

    keepclassmembernames 'class * { \
        java.lang.Class class$(java.lang.String); \
        java.lang.Class class$(java.lang.String, boolean); \
    }'

    // Preserve all native method names and the names of their classes.

    keepclasseswithmembernames includedescriptorclasses: true, 'class * { \
        native <methods>; \
    }'

    // Preserve the special static methods that are required in all enumeration
    // classes.

    keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'

    // Explicitly preserve all serialization members. The Serializable interface
    // is only a marker interface, so it wouldn't save them.
    // You can comment this out if your library doesn't use serialization.
    // If your code contains serializable classes that have to be backward
    // compatible, please refer to the manual.

    keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'

    dontobfuscate

    dontwarn 'java.**'
    dontwarn 'javax.**'
    dontwarn 'org.**'
    dontwarn 'io.**'
}

// til at bygge artefaktet daisy/build/libs/daisy.jar
jar {
    // JAR-filen har en main-metode
    manifest {
        attributes "Main-Class": "eu.nitrogensensor.daisy.DaisyMain"
    }

    // Lav en 'fat JAR' hvor alle biblioteker er pakket med i JAR-filen
    from {
        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    //finalizedBy proguard
}
